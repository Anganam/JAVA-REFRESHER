=== Lesson 1.1===

Using operators, operands and expressions:


    expression <oper> expression = INFIX

    <oper> expression = PREFIX
        -5 
    expression <oper>= postfix 
        2++


=== Lesson 1.2 ====
+ add
- subtract 
* multiply
/ devide
% modulus

Modulus examples:
5/3 => 1 remainder 3
5%3 => 3

10/3 => 3 remainder 1
10%3 => 1 

----

5%3 then 5 - 3 => 2

10%3 then 10 - 3 => 7
            7 - 3 => 4
            4 - 3 => 1
            1 is smaller than 3 so we don't need to reduce again , meaning 1 is the final answer


-10%3 then -10 + 3 => -7
           -7 + 3 => -4
           -4 + 3=> -1
           because numerical size 1 is less then 3 we stop
           we can't move closer to 0 without going past 0

-10.5%3.1 then -10.5 + 3.1 => -7.4
            -7.4 + 3.1 => -4.3
            - 4.3 + 3.1 => - 1.2 
            -1.2 is the answer

OVERFLOW EXAMPLE
Range of byte is -128 -> +127

byte b1 = 100;
byte b2 = 100;
byte b3 = (byte)(b1 + b2); // This will give us 100 + 100 = 200 this is the too big for the byte datatype
                            b3 => -56??

=== lesson 1.3 ===

Using plus operator with sting 


String + Anytype
    => String concatenation 

numericType + numerictYPE 
    => Addition

Any other combination
    => results in compiler error 


INTERESTING EXAMPLE
"hello " + 1 + 2 

=> "hello 1" + 2
=> "hello 12"

1 + 2 + " hello"
=> 3 + " hello"
=> "3 hello" 


=== lesson 1.4 ===
Promoting operands

int + int => int
long + long => long
float + float => float
double + double => double


if double => double  //if one is double then result will be a double apply logic to the below as well
else if float => float
else if long => long
else => long

short s = 99;
byte b = 10;
s = b + s <= compiler error 
    => results in being DataType int


=== lesson 1.5 ===



pre-increment
int x = 99;
int y = ++x;
y => 100 & x => 100;

pre-decrement
int x = 99;
int y = --x;
y => 98 & x => 98;

post-increment
int x = 99;
int y = x++;
y => 99 & x => 100;


post-decrement
int x = 99;
int y = x--;
y => 99 & x => 98;


int x = 99;

x++;    -> x is 100;
++x;    -> x is 101;
x--;    -> x is 100;  
--x;    -> x is 99;

=== lesson 1.6 ===

shift operators

128, 64, 32, 16, 8, 4, 2, 1
  0,  0,  1,  0, 1, 0, 1, 0 => 42
  ?,  0,  0,  1, 0, 1, 0, 1 => 21   >>1
  ?,  ?,  0,  0, 1, 0, 1, 0 => 10   >>2

used for bit flags not really used in main stream


=== lesson 1.7 ===


comparison operators

<   less than
<=  less or equal to
>   greater than
>=  greater or equal to

VALID OPERAND TYPES INCLUDE THE FOLLOWING
byte
short
char
int
long
float
double

Byte, Short Character, Integer, Long, Float, Double;


Note: Number is EXCLUDED 

OPERATORS RESULT in BOOLEAN true or false
EXAMPLES
5 < 6 results in true
5 > 6 results in false

3 <= (2 + 2) results in true


== EQUAL
!= NOT EQUAL

true == false RESULTS IN false
false == false RESULTS IN true
true != false RESULTS IN true


=== Lesson 1.8 === 

Using logical operators 

! symbol will invert the value of a boolean expression. Example:

!true => false
!false => true
!(x==99) will be the same as x != 99

!(x < 99) is the same as x >= 99


~ called tilde 

~ 0000_1111_0101_1100
=> 1111_0000_1010_0011

We can see the tilde sign inverts the 1 bits into 0 bits and vice-versa


and:
1 & 1 => 1
anyone & 0 => 0

or:
anything | 1 => 1
0 | o => 0 


exclusive-or

1 ^ 0 => 1
0 ^ 1 => 1
0 ^ 0 => 0
1 ^ 1 => 0


=== lesson 1.9 ===

Using short-circuit operations

& VS &&

if(customer.hasOverdraft() & customer.frequentVendors().Contains(check.payeel())){
    MAKE THE PAYMENT
}

THE CODE ABOVE WILL CONTINUE TO CHECK customer.frequentVendors EVEN IF THE FIRST OPERANDS RETURNS FALSE. THE CODE BELOW IS MORE EFFICIANENT BECAUSE IT WON'T BOTHER SEARCH IF THE FIRST OPERANDS IS FALSE, WHICH IS SMARTER OPTION


if(customer.hasOverdraft() && customer.frequentVendors().Contains(check.payeel())){
    MAKE THE PAYMENT
}


| VS ||

if ((check.amount()< customer.balance()) || (check.amount()< customer.overdraftLimit())){
    make payment
}


=== Lesson 1.10 ===
Using assignment operators 


int x, y,z;
x = y = z = 0;

InputStreamOO