=== Lesson 1.1===

Using operators, operands and expressions:


    expression <oper> expression = INFIX

    <oper> expression = PREFIX
        -5 
    expression <oper>= postfix 
        2++


=== Lesson 1.2 ====
+ add
- subtract 
* multiply
/ devide
% modulus

Modulus examples:
5/3 => 1 remainder 3
5%3 => 3

10/3 => 3 remainder 1
10%3 => 1 

----

5%3 then 5 - 3 => 2

10%3 then 10 - 3 => 7
            7 - 3 => 4
            4 - 3 => 1
            1 is smaller than 3 so we don't need to reduce again , meaning 1 is the final answer


-10%3 then -10 + 3 => -7
           -7 + 3 => -4
           -4 + 3=> -1
           because numerical size 1 is less then 3 we stop
           we can't move closer to 0 without going past 0

-10.5%3.1 then -10.5 + 3.1 => -7.4
            -7.4 + 3.1 => -4.3
            - 4.3 + 3.1 => - 1.2 
            -1.2 is the answer

OVERFLOW EXAMPLE
Range of byte is -128 -> +127

byte b1 = 100;
byte b2 = 100;
byte b3 = (byte)(b1 + b2); // This will give us 100 + 100 = 200 this is the too big for the byte datatype
                            b3 => -56??

=== lesson 1.3 ===

Using plus operator with sting 


String + Anytype
    => String concatenation 

numericType + numerictYPE 
    => Addition

Any other combination
    => results in compiler error 


INTERESTING EXAMPLE
"hello " + 1 + 2 

=> "hello 1" + 2
=> "hello 12"

1 + 2 + " hello"
=> 3 + " hello"
=> "3 hello" 


=== lesson 1.4 ===
Promoting operands

int + int => int
long + long => long
float + float => float
double + double => double


if double => double  //if one is double then result will be a double apply logic to the below as well
else if float => float
else if long => long
else => long

short s = 99;
byte b = 10;
s = b + s <= compiler error 
    => results in being DataType int


=== lesson 1.5 ===



pre-increment
int x = 99;
int y = ++x;
y => 100 & x => 100;

pre-decrement
int x = 99;
int y = --x;
y => 98 & x => 98;

post-increment
int x = 99;
int y = x++;
y => 99 & x => 100;


post-decrement
int x = 99;
int y = x--;
y => 99 & x => 98;


int x = 99;

x++;    -> x is 100;
++x;    -> x is 101;
x--;    -> x is 100;  
--x;    -> x is 99;

=== lesson 1.6 ===

shift operators

128, 64, 32, 16, 8, 4, 2, 1
  0,  0,  1,  0, 1, 0, 1, 0 => 42
  ?,  0,  0,  1, 0, 1, 0, 1 => 21   >>1
  ?,  ?,  0,  0, 1, 0, 1, 0 => 10   >>2

used for bit flags not really used in main stream


=== lesson 1.7 ===


comparison operators

<   less than
<=  less or equal to
>   greater than
>=  greater or equal to

VALID OPERAND TYPES INCLUDE THE FOLLOWING
byte
short
char
int
long
float
double

Byte, Short Character, Integer, Long, Float, Double;


Note: Number is EXCLUDED 

OPERATORS RESULT in BOOLEAN true or false
EXAMPLES
5 < 6 results in true
5 > 6 results in false

3 <= (2 + 2) results in true


== EQUAL
!= NOT EQUAL

true == false RESULTS IN false
false == false RESULTS IN true
true != false RESULTS IN true


